<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>面试</title>
	<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1">
</head>
<body>
	<h2>HTML</h2>
	<ul>
		<li>
			<h4>HTML5新特性、语义化</h4>
			<p>简洁的DOCTYPE</p>
			<p>简单易记的编码类型<<pre>
				<meta charset="utf-8">
			</pre></p>
			<p>视频和音频</p>
			<p>新的input类型：color/email/date/month/week/time/datetime/number...</p>
			<p>canvas</p>
			<p>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成</p>
			<p>fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。</p>
			<p>绘制圆形：arc(x,y,r,start,stop)</p>
			<p>fillText(text,x,y) - 在 canvas 上绘制实心的文本;strokeText(text,x,y) - 在 canvas 上绘制空心的文本</p>
			<p>createLinearGradient(x,y,x1,y1) - 创建线条渐变;createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变</p>
			<p>moveTo(x,y) 定义线条开始坐标;lineTo(x,y) 定义线条结束坐标</p>
			<p>SVG 是一种使用 XML 描述 2D 图形的语言。Canvas 通过 JavaScript 来绘制 2D 图形。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p>
			<div>
				<canvas id="canvasDemo" width="200" height="100" style="border: 1px solid #000;"></canvas>
			</div>
			<script type="text/javascript">
				var c = document.getElementById('canvasDemo');
				var ctx = c.getContext('2d');
				ctx.fillStyle = '#f00';
				ctx.fillRect(0,0,150,75);

				ctx.moveTo(10,10);
				ctx.lineTo(50,50);
				ctx.stroke();

				ctx.strokeText("Hello", 10, 10);

				//画圆
				ctx.beginPath();
				ctx.arc(100,50,20,0,2*Math.PI);
				ctx.stroke();

				ctx.fillText("Hello", 0, 0);
			</script>
		</li>
		<li>
			<h4>浏览器的标准模式和怪异模式</h4>
			<p>在标准模式下，浏览器按照HTML与CSS标准对文档进行解析和渲染；而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。</p>
			<p>放在网页顶部的doctype声明是让浏览器进入正确呈现模式的关键。浏览器自动切换到恰当的呈现模式，以便正确显示由doctype声明所指定的文档种类。</p>
		</li>
		<li>
			<h4>使用data-的好处</h4>
			<p>data-*:用于存储页面或应用程序的私有自定义数据</p>
			<ol>
				<li>自定义属性，可以被js很好的操作</li>
				<li>h5的新属性</li>
				<li>通过js的element.dataset.*或jQuery的data('*')拿到，*可以为url等字符</li>
				<li>框架的数据绑定</li>
			</ol>
		</li>
		<li>
			<h4>meta viewport原理</h4>
			<p>手机浏览器是把页面放在一个虚拟的“窗口”（viewport）中，通常这个虚拟的“窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。</p>
		</li>
		<li>
			<h4>CSS3新特性，伪类，伪元素，锚伪类</h4>
			<p>CSS 伪类用于向某些选择器添加特殊的效果。</p>
			<p>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）。比如：documen接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使开发者可以提取到这些信息。并且，一些伪元素可以使开发者获取到不存在于源文档中的内容</p>
			<p>伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；伪元素本质上是创建了一个有内容的虚拟容器；CSS3中伪类和伪元素的语法不同；可以同时使用多个伪类，而只能同时使用一个伪元素；</p>
		</li>
		<li>
			<h4>如何实现水平居中和垂直居中</h4>
		</li>
		<li>
			<h4>什么是渐进式渲染</h4>
			<p>指浏览器不用等待所有页面资源都渲染好之后再呈现给用户看，而是边下载边渲染，所以用户打开一个网页的时候往往不能第一时间看到所有的内容，但是能够看到一个大概的样子，后续的内容浏览器会慢慢补上形成一个完整的页面。其实就是为了解决js加载时间的问题。怎么实现：需要服务器端渲染SSR，流行的vue，react都有SSR解决方案。进行首屏渲染，直接返回json和页面</p>
		</li>
		<li>
			<h4>link和@import引入css的区别</h4>
			<p>link属于xhtml标签，而@import是css提供的只能引入css，页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载，Link是xhtml标签，没有兼容性，而@import只有IE5以上才能识别。</p>
		</li>
		<li>
			<h4>grid布局</h4>
			<p>Grid 布局是网站设计的基础，CSS Grid 是创建网格布局最强大和最简单的工具</p>
		</li>
		<li>
			<h4>property：属性，attribute：特性</h4>
			<p>property是DOM中的属性，是JavaScript里的对象；attribute是HTML标签上的特性，它的值只能够是字符串；</p>
			<p>只要是DOM标签中出现的属性（html代码），都是Attribute。然后有些常用特性（id、class、title等），会被转化为Property。</p>
			<p>getAttribute()可以取得任何特性，不管是标准的还是自定义的。</p>
			<p>用setAttrbute()赋值，任何Attribute都可以，包括自定义的,setAttribute()的两个参数，都必须是字符串</p>
			<p>对属性Property可以赋任何类型的值，而对特性Attribute只能赋值字符串！</p>
		</li>
		<li>
			<h4>实现三栏布局（圣杯布局，双飞翼布局，flex布局）</h4>
		</li>
		<li>
			<h4>布局</h4>
			<p>静态布局（Static Layout）:传统Web设计，网页上的所有元素的尺寸一律使用px作为单位</p>
			<p>流式布局（Liquid Layout）:面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）</p>
			<p>自适应布局（Adaptive Layout）:分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围</p>
			<p>响应式布局（Responsive Layout）</p>
			<p>弹性布局（rem/em布局）</p>
		</li>
		<li>
			<h4>清除浮动的原理</h4>
			<p>块格式化上下文(BFC):块级格式化上下文是CSS可视化渲染的一部分。它是一块区域，规定了内部块盒的渲染方式，以及浮动相互之间的影响关系。影响着元素的定位以及与其兄弟元素之间的相互作用。 </p>
		</li>
		<li>
			<h4>padding百分比是相对于父级宽度还是自身的宽度</h4>
		</li>
		<li>
			<h4>CSS 3 如何实现旋转图片（transform: rotate）</h4>
			<h4>transition和animation的区别</h4>
		</li>
		<li>
			<h4>sass less</h4>
		</li>
		<li>
			<h4>对移动端开发了解多少？（响应式设计、Zepto；@media、viewport、JavaScript 正则表达式判断平台。)</h4>
		</li>
		<li>
			<h4>CSS中的长度单位（px,pt,rem,em,ex,vw,vh,vh,vmin,vmax）</h4>
			<p>px：绝对单位，页面按精确像素展示</p>
			<p>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p>
			<p>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。<strong>chrome强制最小字体为12号</strong></p>
			<p>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</p>
			<p>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</p>
			<p>vmin：vw和vh中较小的那个。</p>
			<p>vmax：vw和vh中较大的那个。</p>
			<p>pt:point，大约1/72寸</p>
			<p>ex：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持，firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀)</p>
		</li>
		<li>
			<h4>CSS 选择器的优先级</h4>
			<p>!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性</p>
		</li>
		<li>
			<h4>svg</h4>
		</li>
		<li>
			<h4>js的基本类型有哪些</h4>
			<p>中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。引用类型：Object,Array,Date,RegExp,Function，Object本质上是由一组无序的名值对组成的。</p>
		</li>
		<li>
			<h4>null</h4>
			<p>null表示"没有对象"，即该处不应该有值。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。</p>
			<p>Object.getPrototypeOf(Object.prototype) ====> null</p>
		</li>
		<li>
			<h4>undefined</h4>
			<p>undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。</p>
		</li>
		<li>
			<h4>如何判断一个变量是Array类型？如何判断一个变量是Number类型</h4>
			<p>typeof操作符:alert(typeof []); // "object" </p>
			<p>instanceof操作符:alert(arr instanceof Array); // true</p>
			<p>对象的constructor属性:alert(arr.constructor === Array); // true</p>
			<p>Array.isArray()</p>
			<p>function isArrayFn(value){
				if (typeof Array.isArray === "function") {
					return Array.isArray(value);
				}else{
					return Object.prototype.toString.call(value) === "[object Array]";
				}
			}</p>
			<p>1. isNaN（）是一个函数，用isNaN判断一个变量，返回一个Boolean值。若返回的值为false，则为可以转换成数字类型；返回的值是true，则不能转换成数字类型。</p>
			<p>typeof()判断typeof(num)==="number")&&(num!==Infinity)&&!isNaN(num)</p>
			<p>typeof</p>
		</li>
		<li>
			<h4>JS常见的dom操作api</h4>
		</li>
		<li>
			<h4>事件委托（手写例子），事件冒泡和捕获，如何阻止冒泡？如何组织默认事件？</h4>
		</li>
		<li>
			<h4>对闭包的理解？什么时候构成闭包？闭包的实现方法？闭包的优缺点？</h4>
			<p>匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。</p>
			<p>闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕</p>
			<p>使用闭包有一个优点，也是它的缺点：就是可以把局部变量驻留在内存中，可以避免使用全局变量。(全局变量污染导致应用程序不可预测性，每个模块都可调用必将引来灾难，所以推荐使用私有的，封装的局部变量)</p>
			<script type="text/javascript">
				// var lists = document.getElementsByTagName('li');
				// for(var i = 0 , len = lists.length ; i < len ; i++){
				// (function(index){
				// lists[ index ].onmouseover = function(){
				// alert(index);
				// };
				// })(i)}
			</script>
		</li>
		<li>
			<h4>this</h4>
			<p>this指向的是最终调用它的对象</p>
			<p>如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 </p>
			<h4>改变this的方法</h4>
			<p>new关键字改变this指向</p>
			<p>call（）</p>
			<p>apply（）</p>
			<p>bind（） </p>
			<h6>call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别</h6>
		</li>
		<li>
			<h4>显示原型和隐式原型，手绘原型链，原型链是什么？为什么要有原型链</h4>
		</li>
		<li>
			<h4>创建对象的多种方式</h4>
			<p>工厂方式创建对象：面向对象中的封装函数(内置对象)</p>
			<p>构造函数创建对象</p>
			<p>对象字面量方式创建对象</p>
			<p>用原型方式　</p>
			<p>混合模型</p>
		</li>
		<li>
			<h4>实现继承的多种方式和优缺点</h4>
		</li>
		<li>
			<h4>new 一个对象具体做了什么</h4>
			<ol>
				<li>创建一个新对象，如：var person = {};</li>
				<li>新对象的_proto_属性指向构造函数的原型对象。</li>
				<li>将构造函数的作用域赋值给新对象。（因此 this 就指向了这个新对象）</li>
				<li>执行构造函数内部的代码，将属性添加给person中的this对象。</li>
				<li>返回新对象person。</li>
			</ol>
		</li>
		<li>
			<h4>手写Ajax，XMLHttpRequest</h4>
		</li>
		<li>
			<h4>JS的宿主对象和原生对象的区别</h4>
		</li>
		<li>
			<h4>=== 和 == , [] === [], undefined === undefined,[] == [], undefined == undefined</h4>
		</li>
		<li>
			<h4>typeof能够得到哪些值</h4>
			<p>number, boolean, string, undefined, object, function</p>
			<p>NaN在JavaScript中代表的是特殊非数字值,它本身是一个数字类型。</p>
			<p>对象，数组，null返回object</p>
		</li>
		<li>
			<h4>函数的作用域是什么？js 的作用域有几种？</h4>
			<p>函数作用域，全局作用域，块级作用域</p>
		</li>
		<li>
			<h4>JS如何实现重载和多态</h4>
		</li>
		<li>
			<h4>常用的数组api，字符串api</h4>
		</li>
		<li>
			<h4>原生事件绑定（跨浏览器），dom0和dom2的区别？</h4>
			<p>DOM0就是直接通过 onclick写在html里面的事件</p>
			<p>DOM2级的事件规定了事件流包含三个阶段包括： 1：事件捕获， 2：处于目标阶段， 3：事件冒泡阶段</p>
			<p>由于老版本浏览器不支持，很少有人使用事件捕获。建议使用事件冒泡。</p>
		</li>
		<li>
			<h4>给定一个元素获取它相对于视图窗口的坐标</h4>
			<p>HTML元素的实际内容有可能比分配用来容纳内容的盒子更大，因此可能会出现滚动条，内容区域是视口，当实际内容比视口大的时候，需要把元素的滚动条位置考虑进去。</p>
			<p>浏览器窗口的大小，则是指在浏览器窗口中看到的那部分网页面积，又叫做viewport（视口）。</p>
			<p>网页上的每个元素，都有clientHeight和clientWidth属性。这两个属性指元素的内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。</p>
			<p>document元素的clientHeight和clientWidth属性，就代表了网页的大小:document.documentElement.clientWidth</p>
			<p>网页上的每个元素还有scrollHeight和scrollWidth属性，指包含滚动条在内的该元素的视觉面积。那么，document对象的scrollHeight和scrollWidth属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。</p>
			<p>每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。</p>
			<p>有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是document对象的scrollTop属性；滚动条滚动的水平距离是document对象的scrollLeft属性。</p>
		</li>
		<li>
			<h4>图片滚动懒加载</h4>
			<p>当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。</p>
		</li>
		<li>
			<h4>正则表达式RegExp</h4>
			<p> test() :在字符串中查找符合正则的内容，若查找到返回true,反之返回false.</p>
			<p>search() ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回 -1 </p>
			<p>match() 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。</p>
			<p>replace() :查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。</p>
		</li>
		<li>
			<h4>web端cookie的设置和获取</h4>
			<p>document.cookie</p>
		</li>
		<li>
			<h4>setTimeout和promise的执行顺序</h4>
			<p>then和settimeout执行顺序，即setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.then()在本轮“事件循环”结束时执行。因此then 函数先输出，settimeout后输出。</p>
		</li>
		<li>
			<h4>navigator对象，location和history</h4>
			<p>Window 对象表示浏览器中打开的窗口</p>
			<p>History 对象包含用户（在浏览器窗口中）访问过的 URL。History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。</p>
			<p>Location 对象包含有关当前 URL 的信息。Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。</p>
			<p>Navigator 对象包含有关浏览器的信息。</p>
			<p>Screen 对象包含有关客户端显示屏幕的信息。</p>
		</li>
		<li>
			<h4>JavaScript 垃圾回收</h4>
		</li>
		<li>
			<h4>JavaScript常见的内存泄漏原因</h4>
		</li>
		<li>
			<h4>DOM事件中target和currentTarget的区别</h4>
			<p>currentTarget(你绑定事件的那个元素), target(触发事件的那个目标)</p>
		</li>
		<li>
			<h4>typeof 和 instanceof 区别，instanceof原理</h4>
			<p>JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。</p>
			<p>typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。它返回值是一个字符串，该字符串说明运算数的类型。（typeof 运算符返回一个用来表示表达式的数据类型的字符串。 ）typeof其实就是判断参数是什么类型的实例，就一个参数.typeof 一般只能返回如下几个结果："number"、"string"、"boolean"、"object"、"function" 和 "undefined"。</p>
			<p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。语法：object instanceof constructor</p>
			<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>
		</li>
		<li>
			<h4>js的设计模式</h4>
		</li>
		<li>
			<h4>websocket的工作原理和机制。</h4>
			<p>Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说</p>
		</li>
		<li>
			<h4>es6的继承和es5的继承有什么区别</h4>
		</li>
		<li>
			<h4>seo</h4>
			<p>seo包括关键词分析、网站url分析、代码分析、内链优化、外链</p>
		</li>
		<li>
			<h4>document.write && innerHTML</h4>
			<p>document.write会重绘整个页面，innerHTMl只重绘页面的一部分</p>
		</li>
		<li>
			<h4>h5离线存储</h4>
		</li>
		<li>
			<h4>token</h4>
			<p>当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户段只需要带上这个token前来请求数据
			即可，无需再次带上用户名和密码。
			</p>
		</li>
		<li>
			<h4>调用函数</h4>
			<p>函数调用有四种模式：函数调用模式、构造器调用模式、方法调用模式、apply调用模式</p>
		</li>
		<li>
			<h4>css实现字体大写</h4>
			<p>text-transform</p>
		</li>
		<li>
			<h4>Vue2.0子同级组件之间数据交互</h4>
			<p>1、创建一个事件总线，例如demo中的eventBus，用它作为通信桥梁2、在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数3、在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数</p>
		</li>
		<li>
			<h4>点击穿透原理及解决</h4>
			<p>因为上层元素隐藏或消失了，由于 click 事件的滞后性，同样位置的 DOM 元素触发了 click 事件（如果是 input 则触发了 focus 事件）。在代码中，给我们的感觉就是 target 发生了飘移。</p>
			<p>1. 触摸结束时 touchend 事件触发时，preventDefault()。</p>
			<p>2. 禁止页面缩放 通过设置meta标签，可以禁止页面缩放，部分浏览器不再需要等待 300ms，导致点击穿透。点击事件仍然会触发，但相对较快，所以 click 事件从某种意义上来说可以取代点击事件， 而代价是牺牲少数用户（click 事件触发仍然较慢）的体验。</p>
			<p>3. CSS3 的方法 虽然主要讲的是事件，但是有必要介绍一个 CSS3 的属性 —— pointer-events。</p>
			<p>4.延长消失事件 可以利用jquery的fadeout，设置事件大于300ms。</p>
		</li>
		<li>
			<h4>关于URL编码/javascript/js url 编码/url的三个js编码函数</h4>
			<p>escape(),encodeURI(),encodeURIComponent()</p>
		</li>
		<li>
			<h4>axios</h4>
			<p>请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p>
		</li>
		<li>
			<h4>vue-router有哪几种导航钩子</h4>
			<p>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</p>
		</li>
		<li>
			<h4>vue中computed 和 watch的异同</h4>
			<p>computed 和 watch 都可以观察页面的数据变化。当处理页面的数据变化时，我们有时候很容易滥用watch。 而通常更好的办法是使用computed属性，而不是命令是的watch回调。</p>
			<p>在数据未发生变化时，优先读取缓存。computed 计算属性只有在相关的数据发生变化时才会改变要计算的属性，当相关数据没有变化是，它会读取缓存。而不必想 motheds方法 和 watch 方法是的每次都去执行函数。</p>
			<p>虽然计算属性在大多数情况下是非常适合的，但是在有些情况下我们需要自定义一个watcher，在数据变化时来执行异步操作，这时watch是非常有用的。</p>
		</li>
		<li>
			<h4>函数节流和函数去抖</h4>
			<p>函数节流：在频繁触发的情况下，需要执行的逻辑只有执行完之后，才能继续执行下一次</p>
			<p>函数防抖：在频繁触发的情况下，只有足够的空闲时间，才执行代码一次，如果没有执行完就清除掉，重新执行逻辑</p>
			<p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</p>
		</li>
		<li>
			<h4>一个页面从输入URL到页面加载显示完成，这个过程发生了什么？</h4>
			<ol>
				<li>浏览器查找域名的IP地址</li>
				<li>DNS具体的查找过程：浏览器缓存->系统缓存->路由器缓存</li>
				<li>浏览器向WEB服务器发送一个HTTP请求</li>
				<li>服务器的永久重定向响应</li>
				<li>浏览器跟踪重定向地址</li>
				<li>服务器处理请求</li>
				<li>服务器返回一个HTTP响应</li>
				<li>浏览器显示HTML</li>
				<li>浏览器发送请求获取嵌入在HTML中的资源</li>
				<li>浏览器发送异步请求</li>
			</ol>
		</li>
		<li>
			<h4>js跨域请求方式</h4>
			<ol>
				<li>通过jsonp跨域</li>
				<li>通过修改document.domain跨域</li>
				<li>使用window.name进行跨域</li>
				<li>使用window.postMessage进行跨域</li>
				<li>服务器设置CORS的header为：Access-Control-Allow-Origin</li>
				<li>nginx反向代理</li>
			</ol>
		</li>
		<li>
			<h4>js实现一个持续的动画效果</h4>
			<p>使用requestAnimationFrame</p>
		</li>
		<li>
			<h4>浏览器缓存</h4>
		</li>
	</ul>
</body>
</html>
